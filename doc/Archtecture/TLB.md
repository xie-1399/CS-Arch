### TLB设计

------

TLB用一句话说明：

```
缓存页表中最近使用过的PTE，或者说是页表的Cache
```

但其实TLB并没有明显的规律，也就是说当前在访问一个页，但是未必会访问它相邻的页

在现代处理器中，很多都采用两级的TLB结构（第一级采用哈佛结构，采用全相连的方式，第二级共用，一般采用组相连的结构）

![avatar](https://github.com/xie-1399/RISCVZone/blob/main/doc/pic/TLB/TLB1.png)

其实TLB表项和页表的表项类似，只是增加了一个TAG位

是否支持大小可变的页（页的大小有其两面性）

#### 缺失处理

缺失的几种情况：

```
1：在页表中存在但是TLB中没有
2：在页表中也不存在
```

##### 软件实现（Page Table Walk）

发现TLB缺失，将TLB缺失的虚拟地址保存在寄存器中，同时产生一个异常，在异常处理程序中软件找到对应的页表与PTE，并将其写回TLB之中（但是需要注意的是要有支持直接操作TLB的指令，即读写TLB的指令）

但是需要注意的是：处理器在处理异常的时候需要将流水线中的所有指令全部都抹除掉

![avatar](https://github.com/xie-1399/RISCVZone/blob/main/doc/pic/TLB/TLB2.png)

##### 硬件实现

在MMU中直接去寻找页表，如果从页表中找到的PTE是有效的，就将其写回TLB之中，如果发现寻找到的PTE无效也触发异常

![avatar](https://github.com/xie-1399/RISCVZone/blob/main/doc/pic/TLB/TLB3.png)

##### TLB的写入

当一个页从硬盘搬移到物理内存的时候，需要知道这个页中的内容在物理内存中是否被改变过了

比如说执行了一次store指令，落到了某个页里面，这时候就需要将对应的页表项的脏位置1，当物理内存中的一个页要被替换的时候，需要首先检查它在页表中的脏状态位，如果为1就需要先将这个页写回到硬盘中，然后才能将其进行覆盖

load/store让页表的使用位置1，store还会让脏位置1

如果采用TLB的写回的时候，可以采用的一种方法就是：TLB中记录的所有页都不允许从物理内存中进行替换

TLB是页表的子集，或者可以说如果某种映射关系在页表中不存在了，那么它在TLB中也不应该存在

存在以下两种情况：

（1）一个进程结束的时候，那么对应的TLB中的内容也需要置为无效

（2）当一个进程占用的物理内存比较大的时候，可能会将进程中的一部分不经常使用的页写回到硬盘中（这时TLB中的内容也需要进行无效）

#### 将TLB与Cache接入流水线

正常使用虚拟存储器的系统，处理器送出的虚拟地址首先被TLB转化为对应的物理地址，然后使用物理地址的一部分作为Tag，然后直接进行寻址即可

![avatar](https://github.com/xie-1399/RISCVZone/blob/main/doc/pic/TLB/TLB4.png)

能否将TLB和Cache的访问并行化呢？因为虚拟地址转化的时候低位的offset保持不变，即能否将访问TLB和访问Cache的过程同时进行

![avatar](https://github.com/xie-1399/RISCVZone/blob/main/doc/pic/TLB/TLB5.png)

##### 虚拟Cache的实现

...





















